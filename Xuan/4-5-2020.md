# 4 May 2020 #

## _Interview 07 (105)_ Construct Binary Tree from Preorder and Inorder Traversal ##

Link to original website: https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/

中文版：https://leetcode-cn.com/problems/zhong-jian-er-cha-shu-lcof/

### **Description:** ###

Given preorder and inorder traversal of a tree, construct the binary tree.

**Note:**

You may assume that duplicates do not exist in the tree.

For example, given

```
preorder = [3,9,20,15,7]
inorder = [9,3,15,20,7]
```

Return the following binary tree:

```
    3
   / \
  9  20
    /  \
   15   7
```

### **Solution:** ###

```python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def buildTree(self, preorder: List[int], inorder: List[int]) -> TreeNode:
        if not preorder:
            return None
        
        indexDict = {}
        for i in range(len(inorder)):
            indexDict[inorder[i]] = i
        
        return self._buildTree(preorder, 0, len(preorder) - 1, inorder, 0, len(inorder) - 1, indexDict)
        
    def _buildTree(self, preorder: List[int], preorderStart: int, preorderEnd: int,
                  inorder: List[int], inorderStart: int, inorderEnd: int, indexDict: dict) -> TreeNode:
        if preorderStart > preorderEnd:
            return None
        
        # find the root node
        rootVal = preorder[preorderStart]
        root = TreeNode(rootVal)
        
        if preorderStart == preorderEnd:
            return root
        else:
            indexAtInorder = indexDict[rootVal]
            leftTreeSize = indexAtInorder - inorderStart
            rightTreeSize = inorderEnd - indexAtInorder
            
            leftTree = self._buildTree(preorder, preorderStart + 1, preorderStart + leftTreeSize, 
                                      inorder, inorderStart, indexAtInorder - 1, indexDict)
            rightTree = self._buildTree(preorder, preorderEnd - rightTreeSize + 1, preorderEnd,
                                       inorder, indexAtInorder + 1, inorderEnd, indexDict)
            
            root.left = leftTree
            root.right = rightTree
            return root
  ```
  
  We do it recursively. 
  
  The preorder traversal of a binary tree is: ROOT NODE, LEFT SUBTREE, RIGHT SUBTREE;
  
  The inorder traversal of a binary tree is: LEFT SUBTREE, ROOT NODE, RIGHT SUBTREE.
  
  First node traversed by preorder procedure is ALWAYS the `root` node. All nodes reside on its left subtree would be visited before that node in `inorder` list. So does right subtree (after). Thus, it is easy to know the numbers of nodes of left subtree and right subtree. 
  
  Due to the independence of traversal method and the amount of nodes, we can figure out the boundary of left subtree and right subtree in `preorder` list by the amount of sub-nodes calculated above. Furthermore, we can get the pre- and in-order traversal of these subtrees. Do it recursively, reconstruct its left and right subtree, and reconstruct the whole binary tree in the end.

Time Complexity: $ O(n) $, all nodes reconstruction

Space Complexty: $ O(n) $, space for storing the tree
